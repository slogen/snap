#!/bin/bash

### variables to hold the structural paths we operate on

# all work done under ${top_dir}
top_dir="/mnt/backup/backups/$(hostname).vm"
lock_file="${top_dir}/.lock"
current_dir="${top_dir}/current"
log_name="$(hostname)-backup.log"
log_file="${current_dir}/${log_name}"
snaps_dir="${top_dir}/snaps"
mount_dir="${top_dir}/mount"

### variables for the LVM paths and names
lvm_vg="/dev/h0r5"
lvm_name="host0.libvirt"
lvm_src="${lvm_vg}/${lvm_name}"
lvm_snap_name="${lvm_name}.snap"
lvm_snap="${lvm_vg}/${lvm_snap_name}"

### ${NOW} is used as a unique timestamp for snapshots
NOW="$(date --rfc-3339=seconds)"

# track libvirtd domains that we have suspended in ${suspended_domains[@]}
declare -a suspended_domains

# All functions are written to carefully succeed and exit 0 or exit
# non-0 and cause aborting processing and rolling back

### helper functions for suspending and getting ready to backup

create_snapshot() { 
    lvcreate -L 50G -n "$lvm_snap_name" -s "$lvm_src" 2>&1 \
      | grep -v "leaked on lv" \
      | grep -v "/dev/nbd" 1>&2
}

mount_mount_dir() { 
    mount -o ro,noexec,nosuid "$lvm_snap" "$mount_dir"
}
suspend_domains() {
    local domains=($(virsh -r -q list | grep 'running' | awk '{print $2;}'))
    for domain in "${domains[@]}"; do
	virsh suspend "$domain" || return 1
	suspended_domains[${#suspended_domains[@]}]="$domain"
    done
}

### helper function for cleaning up
umount_mount_dir() {
    findmnt --target "$mount_dir" >/dev/null 2>&1 && \
	{ umount "${mount_dir}" >/dev/null \
	  || umount -f "${mount_dir}" >/dev/null \
	  || umount -l -f "${mount_dir}"; }
}
delete_snapshot() { 
    { 
	lvdisplay "$lvm_snap" >/dev/null && \
	lvremove -f "$lvm_snap" >/dev/null; \
    } 2>&1 | grep -v "leaked on lv" 1>&2
}
resume_domains() {
    local domain
    for domain in "${suspended_domains[@]}"; do
	virsh resume "$domain"
    done
}
completed() {
    # main cleanup-function. tries hard to unroll effects
    # so this function is registered with "trap" INT TERM EXIT
    local errcode="${1:-255}"
    local lockpid=""
    if test -f "${lock_file}"; then
	lockpid=$(< "$lock_file")
	if test "x$lockpid" == "x$$"; then
	    umount_mount_dir || :
	    delete_snapshot || :
	    resume_domains || :
	    rm "${lock_file}" || :
	fi
    fi
    trap - INT TERM EXIT
    exit "$errcode"
}

### helper functions for making the actual backup
## --no-whole-file prevents copying entire file!
rsync_content() {
    local rsync_opts="-a -H -x --inplace --block-size 8192 --del --itemize-changes --stats "
    findmnt --target "$mount_dir" \
	&& nice ionice -c 3 \
	     rsync --no-whole-file \
	        $rsync_opts \
	          --exclude "${log_name}*" \
	          "${mount_dir}/" "${current_dir}/"
}

create_snapshot_and_resume() {
    # helper function that 
    # 1. snapshots
    # 2. always resumes
    # 3. returns whether snapshot was a success (not the resumes)
    echo "--- create_snapshot $(date --rfc-3339=seconds)" 1>&2
    create_snapshot
    local ok="$?"
    echo "--- resume_domains $(date --rfc-3339=seconds)" 1>&2
    resume_domains
    echo "--- back $(date --rfc-3339=seconds)" 1>&2
    return "$ok"
}

### Actual snapshotting on btrfs
make_snap() {
    mkdir -p "${snaps_dir}" \
	&& btrfs subvolume snapshot "${current_dir}" "${snaps_dir}/${NOW/ /_}"
}
cleanup() {
    for d in $(find "$snaps_dir" -mindepth 1 -maxdepth 1 \
	-name "20*-*-*:*:*" -printf "%p\n" \
	| sort -r | tail -n +"${backup_count:-14}")
    do
	btrfs subvolume delete "$d"
    done
}

### Actual code

act() {
    # Algorithm for making the backups
    echo "--- BEGIN BACKUP VMs $(date --rfc-3339=seconds), Timestamp $NOW" 1>&2 \
    suspend_domains \
	&& create_snapshot_and_resume \
	&& mount_mount_dir \
	&& rsync_content \
	&& cleanup
    ok="$?"
    echo "--- END BACKUP VMs $(date --rfc-3339=seconds), status: $ok" 1>&2
    if test "$ok" -eq "0"; then
	make_snap
    fi
    return "$ok"
}

work() {
    # Remember to cleanup!
    trap "completed" INT TERM EXIT
    act
    completed "$?"
}

# Atomic check for ${lock-file}
if ( set -o noclobber; \
	[ -f "$lock_file" ] \
        && ! kill -0 $(< "$lock_file") ; 2>/dev/null \
        && rm -- "$lock_file"; \
	echo "$$" > "$lock_file") 2> /dev/null; then
    # Log to the log-file. Note, that errors in or after make_snap does 
    # not get included in the btrfs snapshot
    work >"${log_file}" 2> >(tee "${log_file}.err" >&2)
    ok="$?"
    exit "$ok"
else
    echo "Another backup is already active!" 1>&2
fi


